# Smart Service Level Agreement

This document provides technical details and describes the design of `merkelized service level agreements` 
in ocean protocol.


## Definition

### Service

Service agreement is a commitment between provider/s and consumer of a service. In this commitment, the provider and 
consumer agree on quality, availability, and responsibilities involved in the service.

![](img/SLA_ServiceDefinition.png)

### Condition

A service provider defines one or more SLAs that apply to their services. Any defined  service 
between parties may/not be associated with a set of conditions
 and `asset/s`. In Ocean Protocol, a SLA is expressed as a set of `conditions` with 
 dependencies where any condition is defined as follows:
 
![SLA Condition Definition](img/SLA_ConditionDefinition.png)


- Control Smart Contract Address: This defines the business logic concerning one or more conditions
in the service agreement. This applies [Storage-Control Pattern](#storage-control-pattern)
- Function Fingerprint: For each condition in the control smart contract, there is a function 
fulfills only one condition
- Dependency Conditions (*Optional*): enforces the execution of the dependency model for this condition 
in terms of list of condition/s that must be fulfilled. The dependency model is defined in terms of tree structure 
in order to avoid any circular dependency and satisfy the `termination` and `correctness` of the model as shown below:

![SLA Dependency Model](img/SLA_DependencyModelDefinition.png)

## Components

![Servie level agreement components](img/SLA_Components.png)

### - Conditions

In Ocean Protocol, Condition has two representations. The first representation defines 
the `event` and the associated `action` where stakeholders (consumers, tribes, marketplaces, 
data scientists, etc.) store it ( in terms of json object) `off-chain`. 
This will enable parties to track the progress of the service agreement. This model is defined as 
[event-action model](#event-action-representation). The second representation is a compressed version of 
the json object and stored `on-chain`. This compressed version holds only the minimal required information 
in order to maintain the stat of the condition in the smart service agreement (on-chain).

#### Event-Action Representation

The below json shows how the service parties interact based on [Trigger-Event-Action](#event-action-pattern) pattern which 
represents the core orchestration pattern in Ocean Service Agreement. 

```json
{
  "serviceAgreementId":{
    "version":"0.1",
    "conditionName":{ 
        "controlContract":{
          "address":"0x123456789abcdef",
          "function":"<Function FingerPrint>",
          "description":"SHOW THIS DESCRIPTION IN FRONTEND"
        },
        "events":{
            "eventName":[
              { // All actions are user defined (by service provider) and will not be store on-chain
                "action":"callback function", // the coressponding action 
                "parameters":{ // mapping parameters from event to action [optional]
                  "event.x": "x",
                  "event.y": "y"
                }
              }
            ]
        },
        "dependency":[{
          "dependencyConditionName": true  // dependency condition status
        }]
    }
  }
}
```
The emitted events are generated by the control/logic contract (smart contract) and handled by the parties that are associated 
to listen to this event. Each event  triggers one or more action/s. These actions are defined 
by the service agreement provider. As a result this will give any entity (tribe, 
organization, consortium, or marketplace) the `optionality` to define there own internal 
actions and integrate their off-chain services using the same way.

Event example in control contract (Best Practice):
```javascript
// use the same function name in the control contract, but keep the first character capital as follows

IsPaymentLocked(bytes32 serviceId, bytes32 conditionId, bool status, address party)

function isPaymentLocked(bytes32 serviceId, bytes32 conditionId, address provider, address arg2){
    ...
    // TODO: user defined business logic in the control contract
    emit IsPaymentLocked(serviceId, conditionId, status, provider);
}
```

#### On-chain Representation

The on-chain representation stores the minimal data associated with a condition 
as shown in the [condition definition section](#condition). The following data structure is 
defined in a `solidity code`:

```javascript

struct Condition {
    bool status;
    address control; // control contract address
    bytes32 [] dependency; // list of dependency conditions (if exist)
}
struct ServiceAgreement{
    bool status;
    address [] parties;
    bytes32 [] conditions;
}

// condition id = hash (control contract address + function fingerprint)
mapping (bytes32 => Condition) conditions;
mapping (bytes32 => ServiceAgreement) agreements;

```



### - Access Control

Access control in the service agreement is defined by control contract address. If the caller (smart contract address) 
has the right to maintain the state of the condition in the storage contract (service agreement contract), the storage contract will grant the control contract an access using 
the following modifier:

```javascript

modifier isValidControlContract(bytes32 serviceId, bytes32 functionFingerprint){
    bytes32 contractHash = keccak256(abi.encodePacked(msg.sender, functionFingerprint));
    // check if the condition belongs this service agreement
    require(agreements[serviceId].conditions[contractHash]);
    // check if the caller is the control contract
    require(conditions[contractHash].control == msg.sender);
    // check if all dependency conditions are fulfilled
    if(conditions[contractHash].dependency.length > 0){
        for(uint256 i = 0; i < conditions[contractHash].dependency.length; i++){
            require(conditions[dependency[i]].status == true);
        }
    }
    _;
}
```

### - Treaty Interface

The control contracts should implements the `treaty interface`. This interface has only two functions in which 
used to fulfill and un-fulfill the conditions in the storage contract (service agreement contract). The interface
is defined as follows:

```javascript
pragma solidity ^0.4.24;

contract Treaty{
    function fulfillCondition(bytes32 service, bytes32 condition, bytes32 function) private returns (bool);
    function unfulfillCondition(bytes32 service, bytes32 condition, bytes32 function) private returns(bool);
}
``` 

## Roles of Ocean Software components
* Squid-lib
  *
* Provider node
  *
* Keeper contracts
  *
* Relay/event handler
  *
* UI/frontend interface/CLI
  *

## Flow
What are the steps involved in setting up and executing a service agreement. 

## Storage
How is the SLA stored and where

## Implementation requirements in supporting the SLA flow
* Squid-lib
  *
* Provider node
  *
* Keeper contracts
  *
* Relay/event handler
  *
* UI/frontend interface/CLI
  *



## Appendix

### Storage-Control Pattern

TBC

### Event-Action Pattern

The event-action pattern is close to [Event-driven Architecture](https://en.wikipedia.org/wiki/Event-driven_architecture). It 
is specified as model to represents the interaction between parties. As shown in the below figure:

![Trigger-event-action pattern](img/SLA_Trigger-Event-Action.png)

TBC


## References
- []()