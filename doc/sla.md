# Merkelized Service Level Agreement

***DISCLAIMER: THIS IS A WORK IN PROGRESS***

This document provides technical details and describes the design of `merkelized service level agreements` 
in ocean protocol.


## Definition

### Service

Service agreement is a commitment between provider/s and consumer of a service. In this commitment, the provider and 
consumer agree on quality, availability, and responsibilities involved in the service.

![](img/SLA_ServiceDefinition.png)

### Condition

A service provider defines one or more SLAs that apply to their services. Any defined  service 
between parties may/not be associated with a set of conditions
 and `asset/s`. In Ocean Protocol, a SLA is expressed as a set of `conditions` with 
 dependencies where any condition is defined as follows:
 
![SLA Condition Definition](img/SLA_ConditionDefinition.png)


- Control Smart Contract Address: This defines the business logic concerning one or more conditions
in the service agreement. This applies [Storage-Control Pattern](#storage-control-pattern)
- Function Fingerprint: For each condition in the control smart contract, there is a function 
fulfills only one condition
- Dependency Conditions (*Optional*): enforces the execution of the dependency model for this condition 
in terms of list of condition/s that must be fulfilled. The dependency model is defined in terms of tree structure 
in order to avoid any circular dependency and satisfy the `termination` and `correctness` of the model as shown below:

![SLA Dependency Model](img/SLA_DependencyModelDefinition.png)

## Components

### 1. SLA Contract

The service level agreement contract is meant to be a [storage contract](#storage-control-pattern) in which maintains the status of conditions for a service. This 
is used to be minimize the interaction between [control contracts](#storage-control-pattern) and decouple the business logic by splitting it into smaller logic (control contracts). Consequently, 
we can reuse the control contracts (pre-defined conditions) to define any kind of service agreements.
For more information about implementation details check out the [Keeper Contracts](#keeper-contracts) section.

### 2. Control Contracts

Control contracts may define the business logic for one or more conditions. As a service provider (i.e marketplace), has the 
right to define conditions by using pre-defined control contracts such as TCR, identities, payments, incentives, token swapping, access,
 etc. or define their own control  contract which implements new conditions. The newly defined 
 control contracts will be whitelisted according to the governance model 
in ocean (ie. It could be TCR based governance approach or community based governance approach). Finally as a consumer you are illegible to `accept/reject`
the service level agreement during the setup phase.

![Servie level agreement components](img/SLA_Components.png)

### 3. Conditions

In Ocean Protocol, A Condition has two representations. The first representation defines 
the `event` and the associated `action` where stakeholders (tribes, marketplaces, 
data scientists, etc.) store it `off-chain` ( in terms of json object). 
This will enable parties to interact asynchronously and track the progress of the service agreement. This model is based on
[the event-driven design pattern](#event-driven-architecture). The second representation is a compressed version of 
the `event based json object` and stored `on-chain`. This compressed version holds only the *minimal required information* 
in order to maintain the state of the condition on-chain.

#### Event-Driven Representation

The below json object shows a generic definition of off-chain SLA object. 

```json
{
  "serviceAgreementId":{
    "version":"0.1",
    "conditionName":{ 
        "controlContract":{
          "address":"0x123456789abcdef",
          "function":"<Function FingerPrint>",
          "description":"SHOW THIS DESCRIPTION IN FRONTEND"
        },
        "events":{
            "eventName":[
              { // off-chain_[optional]_and_defined_by_Service_Agreement_Provider
                "action":"callback function",
                "parameters":{ 
                  "event.x": "x",
                  "event.y": "y"
                }
              }
            ]
        },
        "dependency":[{
          "dependencyConditionName": true  // dependency condition status
        }]
    }
  }
}
```
The emitted events are generated by the control/logic contract (smart contract) and handled by the parties that are associated 
to listen to this event. Each event  triggers one or more action/s. These actions are defined 
by the service agreement provider. Therefore, it provides any entity (tribe, 
organization, consortium, or marketplace) the `optionality` to define there own internal 
actions and integrate their off-chain services.

Event example in control contract (Best Practice):
```javascript
// use the same function name in the control contract, but keep the first character capital as follows

IsPaymentLocked(bytes32 serviceId, bytes32 conditionId, bool status, address party)

function isPaymentLocked(bytes32 serviceId, bytes32 conditionId, address provider, address arg2){
    ...
    // TODO: user defined business logic in the control contract
    emit IsPaymentLocked(serviceId, conditionId, status, provider);
}
```

#### On-chain Representation

The on-chain representation stores the minimal data associated with a condition 
as shown in the [condition definition section](#condition). The following data structure is 
defined in a `solidity code`:

```javascript

    struct Condition{
        bool status;
        bytes32 [] dependency;
    }
    
    struct Agreement{
        bool status;
        bytes32 [] assets;
        address provider;
        bytes32[] conditions;
    }
    
    mapping (bytes32 => Agreement) agreements;
    mapping (bytes32 => Condition) conditions;

```



### 4. Access Control

Access control in the service agreement is defined by control contract address. If the caller (smart contract address) 
has the right to maintain the state of the condition in the storage contract (service agreement contract), the storage contract will grant the control contract an access using 
the following modifier:

```javascript

    modifier isValidControlContract(bytes32 service, bytes32 functionHash){
        // check if the caller is the condition owner (control contract)
        bytes32 condition = keccak256(abi.encodePacked(msg.sender, functionHash, service));
        // check if all the dependency conditions are fulfilled!
        if(conditions[condition].dependency.length > 0) {
            for (uint256 i=0; i < conditions[condition].dependency.length; i++) {
                require(conditions[conditions[condition].dependency[i]].status == true);
            }
        }
        _;
    }
```

### 5. Treaty Interface

The control contracts should implements the `treaty interface`. This interface has only two functions in which 
used to fulfill and un-fulfill the conditions in the storage contract (service agreement contract). For more information about implementation details, checkout this [section](#treaty-implementation).
## Storing and Upgrading SLA

As mentioned before, the service agreement has two representations, the [event-driven based](#event-driven-representation) representation is stored in OceanBD/Provider-py and 
the [on-chain agreement](#on-chain-representation) representation is stored in the service agreement storage contract.

The service agreements could be upgraded by the service provider at anytime but once the `control contracts` smart contracts are deployed 
on the network, there is no way to change them. As a result, the smart contract should be maintained and upgraded according to 
the governance model in ocean. The upgrading mechanism
 uses a directory service contract which acts as Key/value store that allows the logic/control to 
 call other contracts i.e storage contract. Moreover this contract maintains the versioning status of
 interfaces and control contracts. For more information about implementation details of [Directory Service Contract](#directory-service-contract) section.

## Implementation Requirements in Ocean components

This section describes the implementation requirements for the software components of Ocean protocol in order to 
integrate the service level agreement model

### Squid-lib
Squid library ([js](https://github.com/oceanprotocol/squid-js), [python](https://github.com/oceanprotocol/squid-py))
is meant to be an interface which includes the methods to facilitates the interaction with the deployed smart contracts in Ocean Protocol. 
This repository includes also the methods to encrypt and decrypt information. 

**The required APIs for the SLA in Squid as follow:**

- CRUD operations for service level agreement in OceanDB or [Provider-py](https://hub.docker.com/r/oceanprotocol/provider/)
- Setup a service level agreement on-chain which is signed by the consumer
- Generic function which triggers condition calls in control contracts (send transactions)

```python

def trigger_condition(conditionInvokeFunction, parameters, serviceId, conditionId):
    # TODO: generic Interface to invoke condition transaction in a service agreement
    return reciept
    
# setup a service agreement on-chain
def setup_agreement(control_contracts, dependencies, fingerprints, signature):
    # signature : consumer's signature for the data as follows:
    # for each condition in control_contracts:
    #    text += contractAddress+fingerprint[i]+dependencies[i]
    # signature = ECDSA_sign(text)by_consumer_public_key
    # TODO: setup on-chain agreement (call setup service agreement in ServiceAgreement.sol)
    return status
```

### Provider node

Provider node uses bigchainDB in order to store the metadata. The required update in this repository includes
the ability to attach and detach a predefined service level agreement into an existing asset metadata.

![provider - service level agreement](img/SLA_ProviderMetadata.png)

**Implementation Requirements:**

- The provider should provide CRUD APIs of service level agreement [schema](#event-driven-representation) for Squid.
  
### Keeper contracts

The keeper contracts needs to be refactored in order to satisfy the  [storage-control pattern](#storage-control-pattern). The following
contracts are used to be a guide for implementation details of the service level agreement in keeper-contracts repo.

#### Service Level Agreement Contract

The below source code show the required functions in `service level agreement` in ocean:

```javascript
pragma solidity ^0.4.25;

contract SLA{
    
    struct Condition{
        bool status;
        bytes32 [] dependency;
    }
    
    struct Agreement{
        bool status;
        bytes32 [] assets;
        address provider;
        bytes32[] conditions;
    }
    
    mapping (bytes32 => Agreement) agreements;
    mapping (bytes32 => Condition) conditions;
    
    event ConditionStatusChanged(bytes32 service, bytes32 condition, bool status, address party);
    event SetupAgreement(bytes32 service, bool status, address consumer, address provider);
    
    modifier isValidControlContract(bytes32 service, bytes32 functionHash){
        // check if the caller is the condition owner (control contract)
        bytes32 condition = keccak256(abi.encodePacked(msg.sender, functionHash, service));
        // check if all the dependency conditions are fulfilled!
        if(conditions[condition].dependency.length > 0) {
            for (uint256 i=0; i < conditions[condition].dependency.length; i++) {
                require(conditions[conditions[condition].dependency[i]].status == true);
            }
        }
        _;
    }
    
    function generateServiceID(bytes _signature, uint256 _contracts) private view returns (bytes32) {
        return keccak256(abi.encodePacked(_signature, _contracts, block.timestamp));
    }
    
    function setupAgreement(address[] _contracts, 
                            bytes32[] _fingerprints, 
                            int256 [] _parents,
                            int256 [] _childs,
                            bytes _signature,
                            bytes32 [] _assets,
                            address consumer)  public returns(bool) {
       // check conditions length
       require(_contracts.length > 0);
       require(_contracts.length == _fingerprints.length);
       require(_contracts.length == _parents.length);
       // TODO: verify the consumer's signature
       bytes32 service = generateServiceID(_signature, _contracts.length);
       // build the dependency model
       bytes32 [] conds;
       for (uint256 i=0; i < _contracts.length;  i++){
            bytes32 condition = keccak256(abi.encodePacked(_contracts[i], _fingerprints[i], service));
            // TODO: check if the condition is whitelisted
            // TODO: build the dependency as follows
            // parents = [0, 0, 1, 1, 2,  3,  4,  5]
            // childs  = [1, 2, 3, 4, 5, -1, -1, -1]
            // -1 means no dependency
        }
        emit SetupAgreement(service, true, consumer, msg.sender);
        return true;
    }
    
    function setConditionStatus(bytes32 service, bytes32 fingerprint) public 
        isValidControlContract(service, fingerprint) returns (bool){
            bytes32 condition = keccak256(abi.encodePacked(msg.sender, fingerprint, service));
            conditions[condition].status = true;
            return true;
    }
    function fulfillAgreement(bytes32 service) public returns (bool) {
        for (uint256 i=0 ; i < agreements[service].conditions.length; i++){
            if (conditions[agreements[service].conditions[i]].status != true){
                return false;
            }
        }
        agreements[service].status = true;
        return true;
    }
}
```

### Treaty Implementation

The treaty interface is defined as follows:

```javascript
pragma solidity ^0.4.24;

contract Treaty{
    function fulfillCondition(bytes32 service, 
                              bytes32 condition, 
                              bytes32 functionHash) public returns (bool);
    function unfulfillCondition(bytes32 service, 
                                bytes32 condition, 
                                bytes32 functionHash) public returns(bool);
}
``` 


#### Directory Service Contract

TBC

#### Control Contract Example

TBC
  
### Relay/Event handler
  
TBC  
  
### UI/frontend interface/CLI
  
TBC 

## Flow
What are the steps involved in setting up and executing a service agreement. 

TBC


## Marketplace Reference Architecture

TBC

## Curating Service Agreements

TBC

## Appendix

### Storage-Control Pattern

TBC

### Event-Driven Architecture

In the service agreement, the conditions state are represented by events where the state change is the `norm`. 
Events act as alerts for the state change, The [Event-driven Architecture (EDA)](https://en.wikipedia.org/wiki/Event-driven_architecture) is a design pattern built around the `production`, `detection`, and `reaction` to 
events that take place in time. Most of complex engineered systems are loosely coupled networks of 
unassociated components.

The event-action pattern is close to . It 
is specified as model to represents the interaction between parties. As shown in the below figure:

![Event Driven architecture pattern](img/SLA_Trigger-Event-Action.png)

TBC

### Security Threats

TBC


## References
- [Event-Driven Architecture Design Pattern - Wikipedia](https://en.wikipedia.org/wiki/Event-driven_architecture)
- [ABI Function Selectors in Solidity - Solidity Official Documentation](https://solidity.readthedocs.io/en/develop/abi-spec.html#abi-function-selector)